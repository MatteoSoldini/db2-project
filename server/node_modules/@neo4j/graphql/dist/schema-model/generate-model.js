"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateModel = void 0;
const classes_1 = require("../classes");
const constants_1 = require("../constants");
const get_definition_nodes_1 = require("../schema/get-definition-nodes");
const get_field_type_meta_1 = __importDefault(require("../schema/get-field-type-meta"));
const utils_1 = require("../utils/utils");
const Attribute_1 = require("./attribute/Attribute");
const CompositeEntity_1 = require("./entity/CompositeEntity");
const ConcreteEntity_1 = require("./entity/ConcreteEntity");
const Neo4jGraphQLSchemaModel_1 = require("./Neo4jGraphQLSchemaModel");
const authorization_annotation_1 = require("./parser/authorization-annotation");
const cypher_annotation_1 = require("./parser/cypher-annotation");
const utils_2 = require("./parser/utils");
function generateModel(document) {
    const definitionNodes = (0, get_definition_nodes_1.getDefinitionNodes)(document);
    // init interface to typennames map
    const interfaceToImplementingTypeNamesMap = initInterfacesToTypenamesMap(definitionNodes);
    // hydrate interface to typennames map
    hydrateInterfacesToTypenamesMap(definitionNodes, interfaceToImplementingTypeNamesMap);
    const concreteEntities = definitionNodes.objectTypes.map(generateConcreteEntity);
    const concreteEntitiesMap = concreteEntities.reduce((acc, entity) => {
        if (acc.has(entity.name)) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Duplicate node ${entity.name}`);
        }
        acc.set(entity.name, entity);
        return acc;
    }, new Map());
    const interfaceEntities = Array.from(interfaceToImplementingTypeNamesMap.entries()).map(([name, concreteEntities]) => {
        return generateCompositeEntity(name, concreteEntities, concreteEntitiesMap);
    });
    const unionEntities = definitionNodes.unionTypes.map((entity) => {
        return generateCompositeEntity(entity.name.value, entity.types?.map((t) => t.name.value) || [], concreteEntitiesMap);
    });
    return new Neo4jGraphQLSchemaModel_1.Neo4jGraphQLSchemaModel({
        compositeEntities: [...unionEntities, ...interfaceEntities],
        concreteEntities,
    });
}
exports.generateModel = generateModel;
function initInterfacesToTypenamesMap(definitionNodes) {
    return definitionNodes.interfaceTypes.reduce((acc, entity) => {
        const interfaceTypeName = entity.name.value;
        acc.set(interfaceTypeName, []);
        return acc;
    }, new Map());
}
function hydrateInterfacesToTypenamesMap(definitionNodes, interfaceToImplementingTypeNamesMap) {
    return definitionNodes.objectTypes.forEach((el) => {
        if (!el.interfaces) {
            return;
        }
        const objectTypeName = el.name.value;
        el.interfaces?.forEach((i) => {
            const interfaceTypeName = i.name.value;
            const concreteEntities = interfaceToImplementingTypeNamesMap.get(interfaceTypeName);
            if (!concreteEntities) {
                throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find composite entity with name ${interfaceTypeName}`);
            }
            interfaceToImplementingTypeNamesMap.set(interfaceTypeName, concreteEntities.concat(objectTypeName));
        });
    });
}
function generateCompositeEntity(entityDefinitionName, entityImplementingTypeNames, concreteEntities) {
    const compositeFields = entityImplementingTypeNames.map((type) => {
        const concreteEntity = concreteEntities.get(type);
        if (!concreteEntity) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find concrete entity with name ${type}`);
        }
        return concreteEntity;
    });
    // TODO: fix for interfaces annotated with @relationshipFields - which will never have concrete entities
    // if (!compositeFields.length) {
    //     throw new Neo4jGraphQLSchemaValidationError(
    //         `Composite entity ${entityDefinitionName} has no concrete entities`
    //     );
    // }
    // TODO: add annotations
    return new CompositeEntity_1.CompositeEntity({
        name: entityDefinitionName,
        concreteEntities: compositeFields,
    });
}
function generateConcreteEntity(definition) {
    const fields = (definition.fields || []).map((fieldDefinition) => generateField(fieldDefinition));
    const directives = (definition.directives || []).reduce((acc, directive) => {
        acc.set(directive.name.value, (0, utils_2.parseArguments)(directive));
        return acc;
    }, new Map());
    const labels = getLabels(definition, directives.get("node") || {});
    // TODO: add annotations inherited from interface
    return new ConcreteEntity_1.ConcreteEntity({
        name: definition.name.value,
        labels,
        attributes: (0, utils_1.filterTruthy)(fields),
        annotations: createEntityAnnotations(definition.directives || []),
    });
}
function getLabels(definition, nodeDirectiveArguments) {
    // TODO: use when removing label & additionalLabels
    // const nodeExplicitLabels = nodeDirectiveArguments.labels as string[];
    // return nodeExplicitLabels ?? [definition.name.value];
    if (nodeDirectiveArguments.labels?.length) {
        return nodeDirectiveArguments.labels;
    }
    const nodeLabel = nodeDirectiveArguments.label;
    const additionalLabels = (nodeDirectiveArguments.additionalLabels || []);
    const label = nodeLabel || definition.name.value;
    return [label, ...additionalLabels];
}
function generateField(field) {
    const typeMeta = (0, get_field_type_meta_1.default)(field.type); // TODO: without originalType
    if (constants_1.SCALAR_TYPES.includes(typeMeta.name)) {
        const annotations = createFieldAnnotations(field.directives || []);
        return new Attribute_1.Attribute({
            name: field.name.value,
            annotations,
        });
    }
}
function createFieldAnnotations(directives) {
    return (0, utils_1.filterTruthy)(directives.map((directive) => {
        switch (directive.name.value) {
            case "cypher":
                return (0, cypher_annotation_1.parseCypherAnnotation)(directive);
            case "authorization":
                return (0, authorization_annotation_1.parseAuthorizationAnnotation)(directive);
            default:
                return undefined;
        }
    }));
}
function createEntityAnnotations(directives) {
    return (0, utils_1.filterTruthy)(directives.map((directive) => {
        switch (directive.name.value) {
            case "authorization":
                return (0, authorization_annotation_1.parseAuthorizationAnnotation)(directive);
            default:
                return undefined;
        }
    }));
}
//# sourceMappingURL=generate-model.js.map